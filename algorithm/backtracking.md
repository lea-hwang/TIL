# 백트래킹(Backtracking)

> 해를 찾는 도중에 '막히면'(해가 아니면) 되돌아가서 다시 해를 찾아가는 기법

- 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의  부모로 되돌아가(backtracking) 다음 자식 노드로 감

- 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면, 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있다면 유망하다고 함

- 가지치기(pruning): 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않음

- 절차

  1. 상태 공간 트리의 깊이 우선 검색(DFS)을 실시함
  2. 각 노드가 유망한지 점검
  3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속함

- 최적화 문제와 결정 문제를 해결할 수 있음

  - 결정 문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 'yes' 또는 'no'로 답하는 문제

    - 미로 찾기

      - 방향의 우선순위를 먼저 결정(상우하좌 순으로 방문)
      - 방문할 수 있는 곳이 있다면 현재 위치를 stack에 push하고 이동
      - 방문할 수 있는 곳이 없다면 stack에서 현재 위치를 pop하고 길이 있을 때까지 되돌아 가서 다시 경로를 찾는다

    - n-Queen 문제

      - 어떤 퀸을 중심으로 가로, 세로, 대각선에 새로운 퀸을 놓지 못함.

      - 절차

        1. 현재 위치를 v라고 해서 시작.
        2. 새로운 퀸의 위치
           1. 만약 현재 위치에 새로운 퀸을 놓을 수 있으면(가로, 세로, 대각선에 퀸이 있는지 여부 확인) 놓기
           2. 현재 위치에 놓을 수 없으면 오른쪽으로 한칸 이동하면서 위치를 찾기

        3. 첫번째 퀸의 위치를 한칸 오른쪽으로 이동시켜보고 다시 1,2 반복

        ```python
        def checknode(v): # v는 현재 위치
            if promising(v): # 현재 위치에 놓을 수 있다면(가로, 세로, 대각선에 체스가 있는지 확인)
                if there is a solution at v:  # 주어진 퀸을 모두 배치했다면
                    write the solution		  # solution 출력 
                else:						  # 주어진 퀸을 모두 배치하지 못했다면
                    for u in each child of v: # 현재 위치의 아랫줄을 탐색 
                        checknode(u)
        ```

        

    - Map coloring

    - 부분집합의 합(Subset Sum) 문제