# 데이터 구조 및 활용

## 순서가 있는 데이터 구조

### 문자열(String Type)

> 문자들의 나열(sequence of characters)
>
> immutable, ordered, iterable

- 문자열 조회/탐색 및 검증 메소드

  | 문법            | 설명                                                         |
  | --------------- | ------------------------------------------------------------ |
  | s.find(x)       | x의 첫 번째 위치를 반환. 없으면 -1을 반환                    |
  | s.index(x)      | x의 첫 번째 위치를 반환. 없으면 오류 발생                    |
  | s.isalpha()     | 알파벳 문자 여부<br> * 단순 알파벳이 아닌 유니코드 상 Letter (한국어 포함) |
  | s.isupper()     | 대문자 여부                                                  |
  | s.islower()     | 소문자 여부                                                  |
  | s.istitle()     | 타이틀 형식 여부(첫글자가 대문자)                            |
  | s.isspace()     | 공백 여부                                                    |
  | s.startswith(x) | 문자열이 x로 시작하는지 여부                                 |
  | s.endswith(x)   | 문자열이  x로 끝나는지 여부                                  |
  
  - 예시
  
    ```python
    'apple'.find('p') # 1
    'apple'.find('k') # -1
    
    'apple'.index('k') # ValueError: substring not found
    ```
  
- 숫자 판별 메소드

  | 문법          | 설명                                     |
  | ------------- | ---------------------------------------- |
  | s.isdecimal() | 문자열이 0~9까지의 수로 이루어져 있는가? |
  | s.isdigit()   | 문자열이 숫자로 이루어져 있는가?         |
  | s.isnumeric() | 문자열을 수로 볼 수 있는가?              |
  
  
  
- 문자열 변경 메소드

  | 문법                             | 설명                                                         |
  | -------------------------------- | ------------------------------------------------------------ |
  | s.replace(old, new[, count])     | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환                   |
  | s.strip([chars])                 | 공백이나 특정 문자를 제거                                    |
  | s.split([chars])                 | 공백이나 특정 문자를 기준으로 분리                           |
  | 'seperator'.join([**iterable**]) | 구분자로 iterable(literal 안됨)을 합치는데, seperator로 구분이 됨 |
  | s.capitalize()                   | 가장 첫 번째 글자를 대문자로                                 |
  | s.title()                        | `'`나 ` (공백)` 이후를 대문자로                              |
  | s.upper()                        | 모두 대문자                                                  |
  | s.lower()                        | 모두 소문자                                                  |
  | s.swapcase()                     | 대 소문자 변경                                               |

  - 예시

    ```python
    'wooooowoo'.replace('o','!',2) #o 두개를 !로 바꿈
    
    numbers = ['1', '2', '3']
    print(' '.join(numbers))
    # numbers2 = [1, 2, 3] 
    # print(' '.join(numbers2))
    # ->이렇게 하면 에러
    
    print(' '.join(map(str),numbers))
    
    # 문자열 메서드 모두 확인하기
    print(dir('string'))
    
    c = 'monty python'
    c.rstrip(' python')
    # 'm' -> 모든 조합을 이용하여 제거된 결과
    ```

### 리스트(List)

> 순서를 가지는 0개 이상의 객체를 참조하는 자료형

- 리스트 메소드

  | 문법                   | 설명                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | L.append(x)            | 리스트 마지막에 항목 x를 추가                                |
  | L.insert(i, x)         | 리스트 인덱스 i에 항목 x를 삽입<br>* **i가 리스트 길이보다 큰 경우 맨 뒤에 x 삽입** |
  | L.remove(x)            | 리스트 가장 왼쪽에 있는 항목(첫 번째) x를 제거 <br>항목이 존재하지 않을 경우, ValueError |
  | L.pop()                | 리스트 가장 오르쪽에 있는 항목(마지막)을 반환 후 제거        |
  | L.pop(i)               | 리스트 인덱스 i에 있는 항목을 반환 후 제거                   |
  | L.extend(m)            | **순회형** m의 모든 항목들을 리스트 끝에 추가 (+=과 같은 기능) -> 여러 개 추가 가능 |
  | L.index(x, start, end) | 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환<br>없는 경우 ValueError |
  | L.reverse()            | 리스트 거꾸로 뒤집기                                         |
  | L.sort(...)            | 리스트를 정렬 (매개변수 이용가능)<br>reverse = True -> 내림차순 정렬 |
  | L.count(x)             | 리스트에서 항목 x가 몇 개 존재하는지 갯수를 반환             |
  | L.clear()              | 모든 항목 삭제                                               |
  
  - 예시
  
    ```python
    cafe = ['starbucks']
    cafe.extend(['coffee']) # 반드시 iterable을 넣어줘야함
    # cafe.extend('coffee')
    # print(cafe)
    # ['starbucks', 'c', 'o', 'f', 'f', 'e', 'e']
    
    a = [100, 10, 1, 5]
    b = [100, 10, 1, 5]
    
    # 1. 메서드(리스트.sort())
    # 원본 리스트를 정렬시키고, None을 return
    print(a.sort()) # None
    print(a) # [1, 5, 10, 100]
    
    # 2. 함수 (sorted)
    # 원본 리스트는 변경 x, 정렬된 리스트를 return
    print(sordted(b)) # [1, 5, 10, 100]
    print(b) # [100, 10, 1, 5]
    
    cafe = ['abc', 'bdf']
    cafe.insert(100, 'dd') 
    # -> 리스트를 길이를 넘어서는 인덱스는 마지막에 아이템 추가 
    ```
    
    

### 튜플(Tuple)

> 순서를 가지는 0개 이상의 객체를 가지는 불변의 자료형

- 튜플 관련 메소드
  - 리스트 메소드 중 항목을 변경하는 메소드를 제외하고 대부분 동일
  



## 순서가 없는 데이터 구조

### 셋(Set)

>순서없이 0개 이상이 해시가능한 객체를 참조하는 자료형

- 셋 메소드

  | 문법           | 설명                                                         |
  | -------------- | ------------------------------------------------------------ |
  | s.copy()       | 셋의 얕은 복사본을 반환                                      |
  | s.add(x)       | 항목 x가 셋 s에 없다면 추가                                  |
  | s.pop()        | 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거 <br> set이 비어 있을 경우 KeyError |
  | s.remove(x)    | 항목 x를 셋 s에서 삭제 <br>**항목이 존재하지 않을 경우, KeyError** |
  | s.discard(x)   | 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제 -> **항목이 없어도 error가 X** |
  | s.update(t)    | 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가             |
  | s.clear()      | 모든 항목을 제거                                             |
  | s.isdisjoint() | 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True 반환 |
  | s.issubset()   | 셋 s가 셋 t의 하위 셋인 경우, True 반환                      |
  | s.issuperset() | 셋 s가 셋 t의 상위 셋인 경우, True 반환                      |

  

### 딕셔너리(Dictionary)

>순서 없이 키-값(key-value) 쌍으로 이뤄진 객체를 참조하는 자료형

- 딕셔너리 메서드

  | 문법            | 설명                                                         |
  | --------------- | ------------------------------------------------------------ |
  | d.clear()       | 모든 항목을 제거                                             |
  | d.copy()        | 딕셔너리 d의 얕은 복사본을 반환                              |
  | d.keys()        | 딕셔너리 d의 모든 키를 담은 뷰를 반환                        |
  | d.values()      | 딕셔너리 d의 모든 값을 담은 뷰를 반환                        |
  | d.items()       | 딕셔너리 d의 모든 키-값의 쌍을 담은 뷰를 반환                |
  | d.get(k)        | 키 k의 값을 반환하는데, 키 k가 딕셔너리에 d에 없을 경우 None 반환 |
  | d.get(k, v)     | 키 k의 값을 반환하는데, 키 k가 딕셔너리에 d에 없을 경우 v를 반환 |
  | d.pop(k)        | 키 k의 값을 반환하고 키 k의 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 KeyError를 발생 |
  | d.pop(k, v)     | 키 k의 값을 반환하고 키 k의 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 v를 반환 |
  | d.update(... .) | 딕셔너리 d의 값을 매핑하여 업데이트<br>* key에는 `''`를 씌우지 않음 |




# 얕은 복사와 깊은 복사

## 복사 방법

### 할당(Assignment)

> 대입 연산자 `=`를 통한 복사는 해당 객체에 대한 **객체 참조를 복사**
>
> -> 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향

```python
a = [1, 2, 3]
b = a
a[0] = 4
print(a, b)
# [4, 2, 3] [4, 2, 3] -> 객체 참조를 복사하기 때문에 둘다 영향
```



### 얕은 복사(Shallow copy)

> Slice 연산자를 활용하여 **같은 원소를 가진 리스트지만 연산된 결과를 복사** (다른 주소)
>
> -> 그러나 복사하는 리스트의 원소가 주소를 참조하는 경우, 해당 값을 변경하면 이를 참조하는 모든 변수에 영향

```python
a = [1, 2, 3]
b = a[:]
print(a, b) # [1, 2, 3] [1, 2, 3]
b[0] = 5
print(a, b) # [1, 2, 3] [5, 2, 3]

c = [1, 2, ['a', 'b']]
b = a[:]
print(a, b) # [1, 2, ['a', 'b']] [1, 2, ['a', 'b']]
b[2][0] = 0
print(a, b) # [1, 2, [0, 'b']] [1, 2, [0, 'b']] 
			# -> 내부 리스트의 객체 주소를 참조하기 때문에 문제 발생
```



### 깊은 복사(Deep copy)

> 객체 안에 객체가 있을 때는 내부의 객체도 따로 복사를 하여 객체 참조 복사가 일어나지 않도록 함

```python
import copy
a = [1, 2, ['1', '2']]
b = copy.deepcopy(a)
```

