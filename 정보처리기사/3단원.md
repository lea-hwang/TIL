# 3단원

## 스키마

> 데이터베이스의 구조, 제약조건 등을 담고 있는 기본적인 구조

- 외부 스키마: 사용자나 개발자의 관점에서 필요로하는 데이터베이스의 논리적 구조 / 사용자 뷰

- 개념 스키마: 데이터베이스의 전체적인 논리적 구조/ 전체적인 뷰
- 내부 스키마: 물리적 저장장치의 관점에서 보는 데이터 베이스 구조/ 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드이 물리적 순서 등을 표현

## 병행 제어(일관성)

> 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작요을 제어하는 기법

- 미 보장시 
  - **갱**신 손실: 먼저 실행된 트랜잭션 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생하는 오류
  - **현**황 파악오류: 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류
  - **모**순성: 두 트랜잭션이 동시에 실행되어 데이터베이스의 일관성이 결여되는 오류
  - **연**쇄복귀: 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류

### 로킹

- 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 **트랜잭션의 순차적 진행을 보장하는 직렬화 기법**
  - 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
  - 로킹 단위가 작아지면 데이터베이스 공유도가 증가
  - 로킹 단위가 작아지면 로킹 오버헤드가 증가
  - 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
  - 로킹 단위가 작아지면 병행성 수준이 높아짐

### 낙관적 검증

- 일단 트랜잭션을 수행하고, **트랜잭션 종료시 검증을 수행**하여 데이터베이스에 반영하는 기법

### 타임 스탬프 순서

- 트랜잭션이 실행을 시작하기 전에 타임 스탬프를 부여하여 **부여된 시간에 따라 트랜잭션 작업을 수행**하는 기법

### 다중버전 동시성 제어

- 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프와 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근

## 뷰

- 특징
  - 뷰 정의 변경 불가
  - 뷰 자체 인덱스 불가
  - 데이터 변경 제약 존재
  - 논리적 독립성 제공

## 관계 대수

> 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하고 관계로 표현된 데이터를 취급하는 대수적인 연산체계이자 **절차적** 정형언어

- 일반 집합 연산자

  > 수학의 집합 개념

  - 합집합, 교집합, 차집합, 카티션 프로덕션

- 순수 관계 연산자

  > 관계 데이터베이스에 적용할 수 있도록 특별히 개발한 연상자

  - 셀렉트(σ), 프로젝트(π), 조인(▷◁), 디비전(÷)

## 관계 해석

> 튜플 관계 해석과 도메인 관계 해석을 하는 **비절차적** 언어(프레디킷 해석)

- 연산자
  - OR, AND, NOT
- 정량자
  - 전칭 정량자
  - 존재 정량자

## 데이터 모델

- 개념적 설계
  - 사용자의 요구에 **트랜잭션을 모델링**하는 단계
- 논리적 설계
  - **트랜잭션의 인터페이스**를 설계하는 단계
  - **논리적 스키마**를 설계
  - **정규화**
- 물리적 설계
  - 특정 DBMS 의 특성 및 성능을 고려하여 물리적인 스키마를 만드는 단계
  - 객체 생성
  - 반 정규화
  - 레코드 집중의 분석 및 설계
  - 접근 경로 설계

## 정규화

- 1정규형: 속성 한개만 가지도록 구성
- 2정규형: 부분 함수 종속 제거
- 3정규형: 이행 함수 종속 제거
- 보이스-코드 정규형: 결정자가 후보키가 아닌 함수 종속 제거
- 4정규형: 다치 종속성 제거
- 5정규형: 조인 종속성 제거

## 키 종류

- 기본 키: 튜플을 고유하게 식별하는 컬럼
- 대체 키: 후보 키 중에서 기본 키로 선택되지 않은 키
- 후보 키 : 테이블에서 각 튜플을 구별하는 데 기준이 되는 컬럼(기본키 + 대체 키)
- 슈퍼 키: 유일성은 만족하지만  최소성을 만족하지 못하는 키
- 외래 키: 참조 데이터 무결서을 위한 제약조건



## 분산 데이터베이스의 투명성

- **위**치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요. 위치정보가 시스템 카탈로그에 유지되어야 함

- 중**복** 투명성 : DB 객체가 여러 site에 중복 되어 있는지 알 필요가 없는 성질

- **병**행 투명성 : 다수 트랜잭션 동시 수행시 결과의 일관성 유지, Time Stamp, 2PL 구현

- **분**할 투명성 : 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장되어 있음을 인식할 필요가 없음

- **장**애 투명성 : 구성요소(DBMS 등)의 장애에 무관한 트랜잭션의 원자성 유지

  

## 회복 기법

>트랜잭션 도중에 손상된 데이터베이스를 이전 상태로 복귀하는 작업

- 즉각 갱신 기법(Immediate Update)
  트랜잭션의 연산을 수행하여 데이터를 갱신할 때 실제 데이터 베이스에 반영하는 기법
  갱신한 모든 내용을 로그(Log)에 보관합니다.
  회복 작업을 위해 취소(Undo)와 재시도(Redo) 모두 사용할 수 있습니다.

- 연기 갱신 기법(Deffered Updatae)
  트랜잭션을 완료할 때까지 데이터베이스에 갱신을 연기하는 기법
  트랜잭션 수행으로 갱신할 내용은 로그(Log)에 보관합니다.
  트랜잭션이 부분 완료 시점에 Log의 기록을 실제 데이터 베이스에 반영합니다.
  트랜잭션 수행 중에 장애가 발생하여 Rollback하여도 취소(Undo)할 필요가 없습니다.
  재시도(Redo) 작업을 통해 최근의 정상적인 데이터베이스로 회복한 후에 트랜잭션을 재실행할 수 있습니다.

- 검사점 기법(Check Point)
  트랜잭션 중간에 검사점을 로그에 보관하여 트랜잭션 전체를 취소하지 않고 검사점까지 취소할 수 있는 기법

- 그림자 페이지 대체 기법(Shadow Paging)-로그가 필요없음
  트랜잭션의 연산으로 갱신할 필요가 있을 때 복사본인 그림자 페이지를 보관하는 기법
  트랜잭션을 취소할 때 그림자 페이지를 이용하여 회복.
  로그(Log), 취소(Undo), 재시도(Redo)할 필요가 없습니다.